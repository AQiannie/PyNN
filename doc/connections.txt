==============================
Building networks: connections
==============================

Conceptually, a synapse consists of a pre-synaptic structure, the synaptic
cleft, and a post-synaptic structure. In PyNN, the temporal dynamics of the
post-synaptic response are handled by the post-synaptic neuron model
(see :ref:`section-cell-types`). The size of the post-synaptic response
(the "synaptic weight") is handled by the connection model, as is the connection
delay.

At the time of writing, most neuronal network models do not explicitly model
the axon. Rather, the time for propagation of the action potential from
soma/initial segment to axon terminal is added to the synaptic transmission
time to give a composite delay, referred to as "synaptic delay" in this
documentation. For point neuron models, which do not include an explicit model
of the dendrite, the time for transmission of the post-synaptic potential to the
soma may also be considered as being included in the composite synaptic delay.

At a minimum, therefore, a connection in PyNN has two attributes: "weight" and
"delay", which are interpreted as described above. Where the weight has its
own dynamics, a connection may have more attributes: the model for weight
dynamics and the parameters of this model.

.. note:: Currently, PyNN supports only chemical synapses, not electrical synapses.
          If the underlying simulator supports electrical synapses, it is still
          possible to use them in a PyNN model, but this will not be simulator-independent.

.. note:: Currently, PyNN does not support stochastic synapses. If you would
          like to have support for this, or any other feature, please
          `make a feature request`_.

Synapse types
=============

The default synapse type in PyNN has constant synaptic weight. For plastic
synapses, the system of equations that defines the time-evolution of the weight
is encapsulated in a :class:`SynapseDynamics` class.

A :class:`SynapseDynamics` object in turn may contain a "fast" component (for
short-term plasticity), or a "slow" component (for long-term plasticity), or both.

Short-term plasticity models are defined in a :class:`ShortTermPlasticityMechanism`
subclass. PyNN's library of standard models currently contains only one such class:
:class:`TsodyksMarkramMechanism`.

Long-term plasticity models are defined in a :class:`STDPMechanism` object, which
in turn is decomposed into weight-dependence and timing-dependence components.

Here is a full example of creating a :class:`SynapseDynamics` object::

    >>> stdp = STDPMechanism(
    ...     timing_dependence=SpikePairRule(tau_plus=20.0, tau_minus=20.0),
    ...     weight_dependence=AdditiveWeightDependence(w_min=0, w_max=0.04,
    ...                                                A_plus=0.01, A_minus=0.012))
    >>> depressing= TsodyksMarkramMechanism(U=0.5, tau_rec=800.0, tau_facil=0.0)
    >>> synapse_dynamics = SynapseDynamics(fast=depressing, slow=stdp)

Note that not all simulators will support all possible combinations of synaptic
plasticity components, for example the current version of NEST does not support
having both fast and slow components.

.. note:: synaptic weights in PyNN have units of nanoamps for current-based
          synapses and microsiemens for conductance-based synapses. Synaptic
          delays have units of milliseconds.


Connection algorithms
=====================

.. currentmodule:: pyNN.connectors

In PyNN, each different algorithm that can be used to determine which
pre-synaptic neurons are connected to which post-synaptic neurons (also called
a "connection method" or "wiring method") is encapsulated in a separate class.

.. note:: for those interested in design patterns, this is an example of the
          `Strategy Pattern`_

Each such class inherits from a base class, :class:`Connector`, and must
implement a :meth:`connect()` method which takes a :class:`Projection` object
(see below) as its single argument.

PyNN's library of connection algorithms currently contains the following classes:

All-to-all connections
----------------------

Each neuron in the pre-synaptic population is connected to every neuron in the
post-synaptic population. (In this section, the term "population" should be
understood as referring to any of the following: a :class:`Population`,
a :class:`PopulationView`, or an :class:`Assembly` object.)

The :class:`AllToAllConnector` constructor has one
optional argument, ``allow_self_connections``, for use when connecting a
population to itself. By default it is ``True``, but if a neuron should
not connect to itself, set it to ``False``, e.g.::

    >>> connector = AllToAllConnector(allow_self_connections=False,  # no autapses
    ...                               weights=0.01,
    ...                               delays=RandomDistribution('normal', (1.0, 0.2)))

Note that when creating a :class:`Connector` we can specify weights and delays,
as either a numerical value (all connections will have the same value), a
:class:`~pyNN.random.RandomDistribution` object (each connection will have a
different value, drawn from the distribution), or as a string containing a
Python expression including a variable ``d`` (see below). If weights or delays
are not specified, they will be set to default values::

    >>> get_min_delay()
    0.1
    >>> from pyNN.connectors import DEFAULT_WEIGHT
    >>> DEFAULT_WEIGHT
    0.0

One-to-one connections
----------------------

Use of the :class:`OneToOneConnector` requires that the pre- and post-synaptic
populations have the same size. The neuron with index *i* in the pre-synaptic
population is then connected to the neuron with index *i* in the post-synaptic
population.

::

    >>> connector = OneToOneConnector()

Trying to connect two populations with different sizes will raise an Exception.


Connecting neurons with a fixed probability
-------------------------------------------

With the :class:`FixedProbabilityConnector` method, each possible connection
between all pre-synaptic neurons and all post-synaptic neurons is created with
probability ``p_connect``::

    >>> connector = FixedProbabilityConnector(p_connect=0.2,
    ...                                       delays="0.2 + 0.01*d")

Here we have used a distance expression to specify the connection delay,
modelling a constant axonal propagation speed.

The calculation of distance may be controlled by specifying a
:class:`~pyNN.space.Space` object. By default, the 3D distance between cell
positions is used, but the ``axes`` argument may be used to change this, e.g.::

    >>> connector = FixedProbabilityConnector(p_connect=0.2,
    ...                                       delays="0.2 + 0.01*d",
    ...                                       space=Space(axes='xy'))

will ignore the z-coordinate when calculating distance. Similarly, the origins
of the coordinate systems of the two populations and the relative scale of the
two coordinate systems may be controlled using the ``offset`` and
``scale_factor`` arguments to the :class:`Space` constructor. This is useful
when connecting brain regions that have very different sizes but that have a
topographic mapping between them, e.g. retina to LGN to V1.

In more abstract models, it is often useful to be able to avoid edge effects by
specifying periodic boundary conditions, e.g.::

    >>> connector = FixedProbabilityConnector(p_connect=0.2,
   ...                                        delays="0.2 + 0.01*d",
   ...                                        space=Space(periodic_boundaries=((0,500), (0,500), None)))

calculates distance on the surface of a torus of circumference 500 µm
(wrap-around in the x- and y-dimensions but not z). For more information, see
:doc:`space`.


Connecting neurons with a distance-dependent probability
--------------------------------------------------------

For each pair of pre-post cells, the connection probability depends on distance.

The constructor requires a string ``d_expression``, which should be a distance
expression, as described above for delays, but returning a probability (a value
between 0 and 1)::

    >>> DDPC = DistanceDependentProbabilityConnector
    >>> connector = DDPC("exp(-d)")
    >>> connector = DDPC("d<3")

The first example connects neurons with an exponentially-decaying probability.
The second example connects each neuron to all its neighbours within a range of
3 units (typically interpreted as µm, but this is up to the individual user).
Note that boolean values ``True`` and ``False`` are automatically converted to
numerical values ``1.0`` and ``0.0``.

Again, the calculation of distance may be controlled by specifying a
:class:`Space` object, and it is possible to use distance expressions for all of
connection probability, weights and delays::

    >>> connector = DDPC(d_expression="exp(-d/200.0)",
    ...                  weights="0.05*exp(-d*d/4e4)",
    ...                  delays="0.5 + d/100.0")


Divergent/fan-out connections
-----------------------------

The :class:`FixedNumberPostConnector` connects each pre-synaptic neuron to
exactly ``n`` post-synaptic neurons chosen at random::

    >>> connector = FixedNumberPostConnector(n=30))

If ``n`` is less than the size of the post-synaptic population, there are no
multiple connections, i.e., no instances of the same pair of neurons being
multiply connected. If ``n`` is greater than the size of the pre-synaptic
population, all possible single connections are made before starting to add
duplicate connections.

The number of post-synaptic neurons ``n`` can be fixed, or can be chosen at
random from a :class:`~/pyNN.random.RandomDistribution` object, e.g.::

    >>> distr_npost = RandomDistribution(distribution='binomial', parameters=[100,0.3])
    >>> connector = FixedNumberPostConnector(n=distr_npost)


Convergent/fan-in connections
-----------------------------

The :class:`FixedNumberPreConnector` has the same arguments as
:class:`FixedNumberPostConnector`, but of course it connects each
*post*-synaptic neuron to ``n`` *pre*-synaptic neurons, e.g.::

    >>> connector = FixedNumberPreConnector(5)
    >>> distr_npre = RandomDistribution(distribution='poisson', parameters=[5])
    >>> connector = FixedNumberPreConnector(distr_npre)


Creating a small-world network
------------------------------

.. todo:: Pierre to write this bit?


Using the Connection Set Algebra
--------------------------------

The Connection Set Algebra (`Djurfeldt, 2012`_) is a sophisticated system that
allows elaborate connectivity patterns to be constructed using a concise syntax.
Using the CSA requires the Python :mod:`csa` module to be installed
(see :doc:`installation`).

The details of constructing a connection set are beyond the scope of this manual.
We give here a simple example.

    >>> import csa
    >>> cset = csa.full - csa.oneToOne
    >>> connector = CSAConnector(cset)

``csa.full`` represents all-to-all connections, while ``csa.oneToOne``
represents the connection of pre-synaptic neuron *i* to post-synaptic neuron *i*.
By subtracting the second from the first, the connection rule is "all-to-all,
except where the neurons have the same index". If the pre- and post-synaptic
populations are the same population, this is equivalent to
``AllToAllConnector(allow_self_connections=False)``.

.. todo:: explain that weights and delays can either be specified within the
          connection set or within the Connector.

Specifying a list of connections
--------------------------------

Specific connection patterns not covered by the methods above can be obtained by
specifying an explicit list of pre-synaptic and post-synaptic neuron indices,
with weights and delays. Example::

    >>> connections = [
    ...   (0, 0, 0.0, 0.1),
    ...   (0, 1, 0.0, 0.1),
    ...   (0, 2, 0.0, 0.1),
    ...   (1, 5, 0.0, 0.1)
    ... ]
    >>> connector = FromListConnector(connections)



Reading connection patterns to/from a file
------------------------------------------

Connection patterns can be read in from a text file. The file should contain
four columns separated by spaces, containing:

    ``pre-synaptic index`` ``post-synaptic index`` ``weight`` ``delay``

and can be read using::

    >>> connector = FromFileConnector("connections.txt")



User-defined connection algorithms
----------------------------------

If you wish to use a specific connection/wiring algorithm not covered by the
PyNN built-in ones, the options include:

    * constructing a list of connections and use the :class:`FromListConnector` class;
    * using the Connection Set Algebra and the :class:`CSAConnector` class;
    * writing your own :class:`Connector` class - see the
      :doc:`developers_guide` for guidance on this.




Projections
===========

A :class:`Projection` is a container for a set of connections between two
populations of neurons, where by population we mean one of:

    * a :class:`Population` object - a group of neurons all of the same type;
    * a :class:`PopulationView` object - part of a :class:`Population`;
    * a :class:`Assembly` - a heterogeneous group of neurons, which may be of different types.

Creating a :class:`Projection` in PyNN also creates the connections at the
level of the simulator. To create a :class:`Projection` we must specify:

    * the pre-synaptic population;
    * the post-synaptic population;
    * a connection/wiring method.

Optionally, we can also specify:

    * the name of the post-synaptic synapse target (e.g. ‘excitatory’, ‘NMDA’)
      (by default, this is 'excitatory');
    * the synaptic plasticity model (by default, synapses are not plastic);
    * a label (autogenerated if not specified);
    * a random number generator (see :doc:`random_numbers`) for use by the
      connection method (if not specified, a new :class:`~pyNN.random.NumpyRNG`
      object is created for each :class:`Projection`.)

Here is a minimal example::

    >>> excitatory_connections = Projection(pre, post, AllToAllConnector())

and here is a full example::

    >>> sparse_connectivity = FixedProbabilityConnector(0.1, weights=0.01, delays=0.5)
    >>> facilitating = SynapseDynamics(fast=TsodyksMarkramMechanism(U=0.04, tau_rec=100.0, tau_facil=1000.0))
    >>> rng = NumpyRNG(seed=42)
    >>> inhibitory_connections = Projection(pre, post,
    ...                                     method=sparse_connectivity,
    ...                                     target='inhibitory',
    ...                                     synapse_dynamics=facilitating,
    ...                                     rng=rng,
    ...                                     label="inhibitory connections")

Note that the attribute :attr:`synapse_types` of all :ref:`cell type <section-cell-types>`
classes contains a list of the possible values of ``target`` for that cell type::

    >>> post
    foo
    >>> post.celltype
    bar
    >>> post.celltype.synapse_types
    ['excitatory', 'inhibitory']


Accessing weights and delays
----------------------------

The :meth:`Projection.get` method allows the retrieval of connection attributes,
such as weights and delays. Two formats are available. ``'list'`` returns a list
of length equal to the number of connections in the projection, ``'array'``
returns a 2D weight array (with NaN for non-existent connections)::

    >>> excitatory_connections.get('weight', format='list')[3:7]
    [0.20000000000000001, 0.20000000000000001, 0.10000000000000001, 0.10000000000000001]
    >>> excitatory_connections.get('delay', format='array')[:3,:3]
    array([[ 0.2,  0.2,  0.2],
           [ 0.1,  0.1,  0.1],
           [ 0.1,  0.1,  0.1]])

As well as weight and delay, :meth:`Projection.get` can also retrieve the
parameters of synapse dynamics models::

    >>> inhibitory_connections.get('U', format='list')[0:4]
    stuff

It is also possible to retrieve the values of multiple attributes at once, as
either a list of tuples or a tuple of arrays::

    >>> connection_data = excitatory_connections.get('weight', 'delay', format='list')
    >>> for connection in connection_data[:5]:
    ...    w, d = connection
    ...    print "weight = ", w, "delay = ", d
    blah
    >>> weights, delays = excitatory_connections.get('weight', 'delay', format='array')
    >>> for w, d in zip(weights, delays):
    ...    print "weight = ", w, "delay = ", d
    blah


The :meth:`Projection.save` method saves connection attributes to disk.

.. todo:: finish documenting save() method (also decide if it should be write() or save())
          need to think about formats. Text, HDF5, ...

Access to the weights and delays of individual connections is by the
:attr:`connections` attribute, e.g.::

    >>> excitatory_connections.connections[0].weight
    0.2
    >>> excitatory_connections.connections[10].weight
    0.1


Modifying weights and delays
----------------------------

As noted above, weights, delays and other connection attributes can be
specified on creation of a :class:`Projection`, and this is generally the most
efficient time to specify them. It is also possible, however, to modify these
attributes after creation, using the :meth:`set` method.

:meth:`set` accepts any number of keyword arguments, where the key is the
attribute name, and the value is either:

    * a numeric value (all connections will be set to the same value);
    * a :class:`~pyNN.random.RandomDistribution` object (each connection will be
        set to a different value, drawn from the distribution);
    * a list or NumPy array of the same length as the number of connections in
      the :class:`Projection`;
    * a generator.

.. todo:: clarify whether this is the number of *local* connections or the total
          number of connections.

Some examples::

    >>> excitatory_connections.set(weights=0.02)
    >>> excitatory_connections.set(weights=RandomDistribution('gamma', [1, 0.1]),
    ...                            delays=0.3)
    >>> inhibitory_connections.set(U=numpy.linspace(0.4, 0.6, len(inhibitory_connections)),
    ...                            tau_rec=500.0,
    ...                            tau_facil=0.1)

It is also possible to access the attributes of individual connections using the
``connections`` attribute of a :class:`Projection`::

    >>> for c in inhibitory_connections.connections[:5]:
    ...   c.weight *= 2

although this is almost always less efficient than using list- or array-based access.

.. _`make a feature request`: http://neuralensemble.org/trac/PyNN/newticket
.. _`Strategy Pattern`: http://en.wikipedia.org/wiki/Strategy_pattern
.. _`Djurfeldt, 2012`: http://software.incf.org/software/csa/